# 1. 리스트 
```python
#주요 메서드
x = []
x.append(a)
x.sort()
x.reverse()  #리스트의 원소 순서를 모두 뒤집어 놓는다  O(N)
x.insert(삽입위치 인덱스, 삽입할 값)
x.count(특정 값) # 리스트에서 특정 값을 가지는 데이터의 개수를 셀 때
x.remove(특정 값) # 리스트에서 특정 값을 갖는 원소를 제거할 때, 값을 가진 원소가 여러개면 하나만 제거한다

# 리스트 중복된 원소의 개수 구하기
maxCount = 0
for i in set(final_G):
    count = final_G.count(i)
    maxCount = max(count, maxCount)
```

## 1) 리스트 생성
### 리스트 컴프리헨션
array = [i for i in range(20) if i%2==1]    
### 2차원 배열 입력 받기
board = [list(map(int, input().split())) for _ in range(N)]

## 2) 2차원 배열 정렬
```python
x = [[2, 1], [3, 4], [1, 2], [1, 3], [3, 2]]
x.sort(key=lambda x:x[0])   
결과 :  [[1, 2], [1, 3], [2, 1], [3, 4], [3, 2]] #0번째 인덱스 기준 오름차순 정렬, X[1]으로는 정렬되지 않음

x.sort(key=lambda x:(x[0], x[-1]))
결과 :  [[1, 3], [1, 2], [2, 1], [3, 4], [3, 2]] #0번째 인덱스 기준 정렬 후, 동일한 값의 경우 내림차순 정렬

x.sort()
결과 : [[1, 2], [1, 3], [2, 1], [3, 2], [3, 4]]   #0, 1번째 인덱스 모두에 대해 오름차순 정렬
``` 


## 3) 2차원 배열 값 추출 
```python
b = list()
b = sum(x, [])  #sum으로 2차원 리스트를 1차원 리스트로 변환

import itertools
b = list(itertools.chain(*x))   #itertools로 2차원 -> 1차원 변환

b = [data for innerList in x for data in innerList] #

for x1,x2 in x: #반복문으로 변환
    b.append(x1)
    b.append(x2)

# 2차원 배열 열 추출
c = [t[0] for t in x]

# 2차원 리스트 각 행의 최대값을 찾는 방법
map(max, 리스트) 
```

## 4) 리스트 주요 스킬
```python
# 2차원 행<->열 변환
a = [[3, 3, 1, 2], [1, 1, 3, 1], [3, 3, 1, 1], [1, 1, 3, 3]]
a_transpose = [col for col in zip(*a)]

# 배열 내 모든 값 특정 값으로 빼기
B = [4, 5, 8]
B = list(map(lambda x-B[0], B))

# 배열 복사
import copy
copied_array = copy.deepcopy(a) # 1. deepcopy 사용

b = list(a) # 2. list를 생성할 때 매개변수에 원본을 전달
c = a[:]    # 3. 슬라이싱 -> 2차원 배열 되는지 확인해보자


# isPartExist 배열 내의 값을 공백으로 구분하여 출력
print(*isPartExist, sep=" ")
```

---
# 02. 딕셔너리
```python
# 입력, 추가
data = dict()
data['사과'] = 'Apple'
data['바나나'] = 'Banana'
data['코코넛'] = 'Coconut'

# 딕셔너리를 리스트로 변경
my_dict = {'a': 1, 'b': 2, 'c': 3}

# key만 리스트로 변경하고 싶을 때
keys_list = list(my_dict)
print(keys_list)  # Output: ['a', 'b', 'c']

# key-value pairs를 리스트로 변환하고 싶으면, .items() 추가 필요
items_list = list(my_dict.items())
print(items_list)  # Output: [('a', 1), ('b', 2), ('c', 3)]

```
# 10. DFS, DFS 풀이 공통 패턴
```python
# DFS 사용 시 재귀 리밋 적용
import sys
sys.setrecursionlimit(10**6)

# BFS로 풀이 시
from collections import deque

# 2차원에서 상,하,좌,우 이동 시
dir = [[-1,0], [1,0], [0,-1], [0,1]]
for dy, dx in dir:
    ny, nx = y+dy, x+dx


```
# 11. 이진탐색 공통 패턴
```python
# value가 array에서 몇개 있는지 반환하는 함수, array는 정렬되어 있어야 
from bisect import bisect_left, bisect_right

def count_by_range(array, value):
    right_index = bisect_right(array, value)
    left_index = bisect_left(array, value)
    return right_index - left_index


```


# 99. 코딩테스트 유용 스킬
```python
# 입출력 속도 # 입력의 개수가 많을 경우 input() 사용 시 시간 초과 될 수 있다
input() < sys.stdin.readline()

# end=" " : 개행 삭제하여 다음의 print문과 같은 라인에 출력됨
print(str_loop[p], end='')

# sep=" " : print문 출력문들 사이에 들어갈 내용 입력 가능
print('S','E','P', sep='@') 

# format
print("{0}월{1}일 입니다.".format(10,31))
print("%s을 %d개 주세요."%("아이스크림", 10))

# in 연산자와 not in 연산자, True 또는 False 반환
x in 리스트
x not in 문자열

# itertools
from itertools import permutations
from itertools import combinations

data = ['A', 'B', 'C']
result = list(permutations(data, 3))
result = list(combinations(data, 2))

# 문자열 연산
ord('A') # 문자열 -> 아스키코드 # 65
chr(65) # 아스키코드 -> 문자열  # A



# 집합 자료형 # 리스트 중복 제거에 주로 사용, |, &, -
data = set([1,1,2,3,4,4,5])


# 수 자료형 연산
/ : 나누기
% : 나머지
// : 몫
divmod : 

# math
import math
print(math.factorial(5)) # 5 팩토리얼 출력
print(math.sqrt(7)) # 7의 제곱근 출력
print(math.gcd(21,14)) # 21과 14의 최대 공약수 , 7
print(math.pi) # 파이 출력
print(math.e) # 자연상수 출력


# 값이 알파벳인지 숫자인지 확인
"a".isalpha() # True
"3".isalpha() # False

"3".isdigit() # True
"a".isdigit() # False




# Collection 라이브러리의 Counter는 등장 횟수를 세는 기능을 제공한다.
from collections import Counter

counter = Counter(['red', 'blue', 'red', 'green', 'blue', 'blue'])

print(counter['blue'])
print(dict(counter))

# 구간합 구하기
n = 5
datas = [10, 20, 30, 40, 50]

def partial_sum(l, r, array):
    sum_val = 0
    prefix_sum = [0]
    for a in array:
        sum_val += a
        prefix_sum.append(sum_val)
    return (prefix_sum[r] - prefix_sum[l - 1])
partial_sum(2,3,datas)  #2~3번째 구간 숫자의 합


``` 
